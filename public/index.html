<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cognitive Insight Engine</title>
    <style>
        :root {
            --red: #FF2E63;
            --blue: #08D9D6;
            --yellow: #FFD700;
            --orange: #FF6B35;
            --purple: #AA00FF;
            --green: #00FF8C;
            --dark: #0A0A0F;
            --card: #121218;
            --border: #2A2A40;
            --text: #FFFFFF;
            --muted: #B8B8D1;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--dark);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            background: linear-gradient(135deg, var(--red), var(--purple));
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .input-section {
            background: var(--card);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            font-size: 1rem;
            color: var(--text);
            resize: vertical;
            margin-bottom: 15px;
            font-family: inherit;
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--blue);
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, var(--red), var(--purple));
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        .secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--border);
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            color: var(--muted);
        }
        
        .stats span {
            color: var(--yellow);
            font-weight: bold;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: var(--card);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid var(--border);
        }
        
        .card h3 {
            color: var(--blue);
            margin-bottom: 15px;
        }
        
        .pattern-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--red);
            margin-bottom: 10px;
        }
        
        .score-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--red), var(--purple));
            border-radius: 4px;
        }
        
        .marker {
            background: var(--purple);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: inline-block;
            margin: 2px;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üß† Cognitive Insight Engine</h1>
            <p>Psychological Pattern Analysis</p>
        </header>
        
        <section class="input-section">
            <textarea id="textInput">I always feel like I should be doing better, but nothing ever feels good enough. It's probably all my fault.</textarea>
            
            <div class="controls">
                <button id="analyzeBtn">üîç Analyze</button>
                <button class="secondary" id="exampleBtn">üìã Example</button>
                <button class="secondary" id="clearBtn">üóëÔ∏è Clear</button>
            </div>
            
            <div class="stats">
                <div>Words: <span id="wordCount">0</span></div>
                <div>Markers: <span id="markerCount">0</span></div>
            </div>
        </section>
        
        <div class="dashboard" id="dashboard" style="display: none;">
            <div class="card">
                <h3>üéØ Patterns</h3>
                <div id="patternsList"></div>
            </div>
            
            <div class="card">
                <h3>üí° Insights</h3>
                <div id="insightsList"></div>
            </div>
            
            <div class="card">
                <h3>‚ö†Ô∏è Conflicts</h3>
                <div id="conflictsList"></div>
            </div>
        </div>
    </div>

    <script>
        // Knowledge Base
        const KB = {
            lexicon: {
                'always': {category:'absolutist', weight:2.5},
                'never': {category:'absolutist', weight:2.5},
                'everything': {category:'absolutist', weight:2.2},
                'nothing': {category:'absolutist', weight:2.4},
                'should': {category:'imperative', weight:3.0},
                'must': {category:'imperative', weight:3.5},
                'failure': {category:'self_critic', weight:3.8},
                'disaster': {category:'catastrophizing', weight:4.0},
                'terrible': {category:'catastrophizing', weight:3.2},
                'my fault': {category:'personalization', weight:4.0}
            },
            
            patterns: {
                'absolutist': {name:'All-or-Nothing', driver:'control'},
                'imperative': {name:'Should Thinking', driver:'validation'},
                'self_critic': {name:'Self-Criticism', driver:'validation'},
                'catastrophizing': {name:'Catastrophizing', driver:'safety'},
                'personalization': {name:'Personalization', driver:'responsibility'}
            },
            
            drivers: {
                'control': {name:'Control'},
                'validation': {name:'Validation'},
                'safety': {name:'Safety'},
                'responsibility': {name:'Responsibility'}
            }
        };

        // Cognitive Engine
        class Engine {
            analyze(text) {
                const words = text.toLowerCase().split(/\s+/);
                const hits = [];
                
                // Find markers
                for (let i = 0; i < words.length; i++) {
                    // Single words
                    if (KB.lexicon[words[i]]) {
                        hits.push({
                            word: words[i],
                            category: KB.lexicon[words[i]].category,
                            weight: KB.lexicon[words[i]].weight
                        });
                    }
                    
                    // Two-word phrases
                    if (i < words.length - 1) {
                        const phrase = words[i] + ' ' + words[i + 1];
                        if (KB.lexicon[phrase]) {
                            hits.push({
                                word: phrase,
                                category: KB.lexicon[phrase].category,
                                weight: KB.lexicon[phrase].weight
                            });
                            i++;
                        }
                    }
                }
                
                // Aggregate patterns
                const patterns = {};
                hits.forEach(hit => {
                    const cat = hit.category;
                    patterns[cat] = patterns[cat] || {score:0, count:0};
                    patterns[cat].score += hit.weight;
                    patterns[cat].count++;
                });
                
                // Infer drivers
                const drivers = {};
                Object.entries(patterns).forEach(([cat, data]) => {
                    const driver = KB.patterns[cat]?.driver;
                    if (driver) {
                        drivers[driver] = drivers[driver] || {score:0};
                        drivers[driver].score += data.score;
                    }
                });
                
                // Normalize drivers
                Object.keys(drivers).forEach(d => {
                    drivers[d].normalized = Math.min(10, drivers[d].score / 3);
                });
                
                // Detect conflicts
                const conflicts = [];
                const driverKeys = Object.keys(drivers);
                for (let i = 0; i < driverKeys.length; i++) {
                    for (let j = i + 1; j < driverKeys.length; j++) {
                        if (drivers[driverKeys[i]].normalized > 4 && 
                            drivers[driverKeys[j]].normalized > 4) {
                            conflicts.push(`${KB.drivers[driverKeys[i]]?.name} vs ${KB.drivers[driverKeys[j]]?.name}`);
                        }
                    }
                }
                
                // Generate insights
                const insights = [];
                const topPattern = Object.entries(patterns)
                    .sort((a, b) => b[1].score - a[1].score)[0];
                
                if (topPattern) {
                    insights.push(`Primary pattern: ${KB.patterns[topPattern[0]]?.name}`);
                }
                
                const topDriver = Object.entries(drivers)
                    .sort((a, b) => b[1].score - a[1].score)[0];
                
                if (topDriver) {
                    insights.push(`Main driver: ${KB.drivers[topDriver[0]]?.name}`);
                }
                
                return {
                    hits: hits,
                    patterns: patterns,
                    drivers: drivers,
                    conflicts: conflicts,
                    insights: insights,
                    metadata: {
                        wordCount: words.length,
                        markerCount: hits.length
                    }
                };
            }
        }

        // Initialize
        const engine = new Engine();
        const textInput = document.getElementById('textInput');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const exampleBtn = document.getElementById('exampleBtn');
        const clearBtn = document.getElementById('clearBtn');

        // Update stats
        function updateStats() {
            const text = textInput.value;
            const words = text.trim() === '' ? 0 : text.split(/\s+/).length;
            
            // Count markers
            let markerCount = 0;
            Object.keys(KB.lexicon).forEach(word => {
                const regex = new RegExp('\\b' + word + '\\b', 'gi');
                const matches = text.match(regex);
                if (matches) markerCount += matches.length;
            });
            
            document.getElementById('wordCount').textContent = words;
            document.getElementById('markerCount').textContent = markerCount;
        }

        // Analyze text
        function analyzeText() {
            const text = textInput.value.trim();
            
            if (text.length < 10) {
                alert('Please enter at least 10 characters.');
                return;
            }
            
            const result = engine.analyze(text);
            
            // Update patterns
            const patternsList = document.getElementById('patternsList');
            const patternsHTML = Object.entries(result.patterns)
                .sort((a, b) => b[1].score - a[1].score)
                .map(([name, data]) => {
                    const percentage = Math.min(100, (data.score / 10) * 100);
                    return `
                        <div class="pattern-item">
                            <div>${KB.patterns[name]?.name || name}</div>
                            <div class="score-bar">
                                <div class="score-fill" style="width: ${percentage}%"></div>
                            </div>
                            <div>Score: ${data.score.toFixed(1)} | Count: ${data.count}</div>
                        </div>
                    `;
                }).join('');
            patternsList.innerHTML = patternsHTML || '<div>No patterns detected</div>';
            
            // Update insights
            const insightsList = document.getElementById('insightsList');
            insightsList.innerHTML = result.insights
                .map(insight => `<div class="pattern-item">${insight}</div>`)
                .join('') || '<div>No insights generated</div>';
            
            // Update conflicts
            const conflictsList = document.getElementById('conflictsList');
            if (result.conflicts.length > 0) {
                conflictsList.innerHTML = result.conflicts
                    .map(conflict => `<div class="pattern-item">${conflict}</div>`)
                    .join('');
            } else {
                conflictsList.innerHTML = '<div class="pattern-item">No conflicts detected</div>';
            }
            
            // Show dashboard
            document.getElementById('dashboard').style.display = 'grid';
            
            // Add markers display
            const markers = result.hits.map(hit => hit.word);
            const uniqueMarkers = [...new Set(markers)];
            const markersHTML = uniqueMarkers.map(word => {
                const category = KB.lexicon[word]?.category;
                const color = category === 'absolutist' ? 'var(--red)' :
                             category === 'imperative' ? 'var(--yellow)' :
                             category === 'catastrophizing' ? 'var(--orange)' : 'var(--purple)';
                return `<span class="marker" style="background: ${color}">${word}</span>`;
            }).join(' ');
            
            if (markersHTML) {
                const markerCard = document.createElement('div');
                markerCard.className = 'card';
                markerCard.innerHTML = `<h3>üî§ Markers</h3><div>${markersHTML}</div>`;
                document.getElementById('dashboard').appendChild(markerCard);
            }
        }

        // Load example
        function loadExample() {
            const examples = [
                "I always feel like I should be doing more, but nothing ever feels good enough.",
                "Everything has to be perfect or it's completely worthless.",
                "I'm never going to succeed at this rate. It's probably all my fault.",
                "They probably think I'm incompetent. I should have done better."
            ];
            
            const randomExample = examples[Math.floor(Math.random() * examples.length)];
            textInput.value = randomExample;
            updateStats();
            analyzeText();
        }

        // Clear text
        function clearText() {
            textInput.value = '';
            updateStats();
            document.getElementById('dashboard').style.display = 'none';
        }

        // Event listeners
        textInput.addEventListener('input', updateStats);
        analyzeBtn.addEventListener('click', analyzeText);
        exampleBtn.addEventListener('click', loadExample);
        clearBtn.addEventListener('click', clearText);

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                analyzeText();
            }
        });

        // Initial setup
        updateStats();
        
        // Auto-analyze on load
        setTimeout(() => {
            analyzeText();
        }, 100);
    </script>
</body>
</html>
