<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cognitive Insight Engine v3.0</title>
    <style>
        /* ========== BOLD COLOR THEME ========== */
        :root {
            --red: #FF2E63;
            --blue: #08D9D6;
            --yellow: #FFD700;
            --orange: #FF6B35;
            --purple: #AA00FF;
            --green: #00FF8C;
            --dark: #0A0A0F;
            --card: #121218;
            --border: #2A2A40;
            --text: #FFFFFF;
            --muted: #B8B8D1;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--dark);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* ========== HEADER ========== */
        .header {
            background: linear-gradient(135deg, var(--red), var(--purple));
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid var(--border);
            box-shadow: 0 10px 30px rgba(255, 46, 99, 0.3);
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
        }
        
        /* ========== INPUT SECTION ========== */
        .input-section {
            background: var(--card);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid var(--border);
        }
        
        .input-section h2 {
            color: var(--blue);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            font-size: 1rem;
            color: var(--text);
            resize: vertical;
            margin-bottom: 15px;
            font-family: inherit;
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--blue);
            box-shadow: 0 0 20px rgba(8, 217, 214, 0.3);
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, var(--red), var(--purple));
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 46, 99, 0.4);
        }
        
        button.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--border);
        }
        
        button.secondary:hover {
            border-color: var(--blue);
            background: rgba(8, 217, 214, 0.1);
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            color: var(--muted);
            font-size: 0.9rem;
        }
        
        .stats span {
            color: var(--yellow);
            font-weight: bold;
        }
        
        /* ========== DASHBOARD ========== */
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: var(--card);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid var(--border);
            transition: all 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            border-color: var(--blue);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        
        .card h3 {
            color: var(--blue);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* ========== PATTERNS LIST ========== */
        .pattern-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .pattern-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--red);
        }
        
        .pattern-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .pattern-score {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .score-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--red), var(--purple));
            border-radius: 4px;
        }
        
        /* ========== INSIGHTS ========== */
        .insight-item {
            background: rgba(8, 217, 214, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid var(--blue);
        }
        
        /* ========== CONFLICTS ========== */
        .conflict-item {
            background: rgba(255, 46, 99, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid var(--red);
        }
        
        /* ========== MARKERS ========== */
        .marker-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .marker {
            background: var(--purple);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .marker.absolutist { background: var(--red); }
        .marker.imperative { background: var(--yellow); color: #000; }
        .marker.catastrophizing { background: var(--orange); }
        .marker.self_critic { background: var(--purple); }
        .marker.personalization { background: var(--blue); }
        .marker.mind_reading { background: var(--green); color: #000; }
        
        /* ========== RESPONSIVE ========== */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            button {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>üß† Cognitive Insight Engine</h1>
            <p>Advanced psychological pattern analysis with bold color visualization</p>
        </header>
        
        <!-- Input Section -->
        <section class="input-section">
            <h2>üìù Enter Your Thoughts</h2>
            <textarea id="textInput" placeholder="Write about your thoughts, feelings, or experiences... 
Example: 'I always feel like I should be doing more, but nothing ever feels good enough. It's a disaster waiting to happen.'">
I always feel like I should be doing better, but nothing ever feels good enough. It's probably all my fault. They probably think I'm incompetent. I must avoid failure at all costs.</textarea>
            
            <div class="controls">
                <button id="analyzeBtn" onclick="analyzeText()">
                    üîç Analyze Cognitive Patterns
                </button>
                <button class="secondary" onclick="loadExample()">
                    üìã Load Example
                </button>
                <button class="secondary" onclick="clearText()">
                    üóëÔ∏è Clear Text
                </button>
            </div>
            
            <div class="stats">
                <div>Words: <span id="wordCount">0</span></div>
                <div>Characters: <span id="charCount">0</span></div>
                <div>Markers: <span id="markerCount">0</span></div>
            </div>
        </section>
        
        <!-- Dashboard -->
        <div class="dashboard" id="dashboard" style="display: none;">
            <!-- Patterns Card -->
            <div class="card">
                <h3>üéØ Detected Patterns</h3>
                <div class="pattern-list" id="patternsList"></div>
            </div>
            
            <!-- Insights Card -->
            <div class="card">
                <h3>üí° Key Insights</h3>
                <div id="insightsList"></div>
            </div>
            
            <!-- Conflicts Card -->
            <div class="card">
                <h3>‚ö†Ô∏è Internal Tensions</h3>
                <div id="conflictsList"></div>
            </div>
            
            <!-- Markers Card -->
            <div class="card">
                <h3>üî§ Cognitive Markers</h3>
                <div class="marker-list" id="markersList"></div>
            </div>
        </div>
    </div>

    <script>
        // ========== KNOWLEDGE BASE ==========
        const KNOWLEDGE_BASE = {
            lexicon: {
                'always': { category: 'absolutist', weight: 2.5 },
                'never': { category: 'absolutist', weight: 2.5 },
                'everything': { category: 'absolutist', weight: 2.2 },
                'nothing': { category: 'absolutist', weight: 2.4 },
                'should': { category: 'imperative', weight: 3.0 },
                'must': { category: 'imperative', weight: 3.5 },
                'have to': { category: 'imperative', weight: 2.8 },
                'failure': { category: 'self_critic', weight: 3.8 },
                'stupid': { category: 'self_critic', weight: 3.0 },
                'useless': { category: 'self_critic', weight: 3.5 },
                'disaster': { category: 'catastrophizing', weight: 4.0 },
                'terrible': { category: 'catastrophizing', weight: 3.2 },
                'worst': { category: 'catastrophizing', weight: 3.5 },
                'my fault': { category: 'personalization', weight: 4.0 },
                'because of me': { category: 'personalization', weight: 3.5 },
                'they think': { category: 'mind_reading', weight: 2.5 },
                'probably thinks': { category: 'mind_reading', weight: 2.2 },
                'feel like': { category: 'emotional', weight: 2.0 }
            },
            
            patterns: {
                'absolutist': { 
                    name: 'All-or-Nothing Thinking', 
                    driver: 'control',
                    description: 'Seeing things in black and white, without middle ground.'
                },
                'imperative': { 
                    name: 'Should/Must Thinking', 
                    driver: 'validation',
                    description: 'Rigid rules about how things "should" be.'
                },
                'catastrophizing': { 
                    name: 'Catastrophizing', 
                    driver: 'safety',
                    description: 'Expecting the worst possible outcome.'
                },
                'self_critic': { 
                    name: 'Self-Criticism', 
                    driver: 'validation',
                    description: 'Harsh judgment of oneself.'
                },
                'personalization': { 
                    name: 'Personalization', 
                    driver: 'responsibility',
                    description: 'Taking excessive responsibility for events.'
                },
                'mind_reading': { 
                    name: 'Mind Reading', 
                    driver: 'validation',
                    description: 'Assuming you know what others are thinking.'
                },
                'emotional': { 
                    name: 'Emotional Reasoning', 
                    driver: 'certainty',
                    description: 'Believing feelings reflect objective reality.'
                }
            },
            
            drivers: {
                'control': { name: 'Control & Certainty' },
                'validation': { name: 'Validation & Worth' },
                'safety': { name: 'Safety & Protection' },
                'responsibility': { name: 'Responsibility' },
                'certainty': { name: 'Certainty' }
            }
        };

        // ========== COGNITIVE ENGINE ==========
        class CognitiveEngine {
            constructor(kb) {
                this.kb = kb;
            }
            
            analyze(text) {
                const words = text.toLowerCase().split(/\s+/);
                const hits = [];
                
                // Find markers
                for (let i = 0; i < words.length; i++) {
                    // Check single words
                    if (this.kb.lexicon[words[i]]) {
                        hits.push(this.createHit(words[i], i));
                    }
                    
                    // Check two-word phrases
                    if (i < words.length - 1) {
                        const twoWords = words[i] + ' ' + words[i + 1];
                        if (this.kb.lexicon[twoWords]) {
                            hits.push(this.createHit(twoWords, i));
                            i++; // Skip next word since we used it
                        }
                    }
                }
                
                // Aggregate patterns
                const patterns = this.aggregatePatterns(hits);
                
                // Infer drivers
                const drivers = this.inferDrivers(patterns);
                
                // Detect conflicts
                const conflicts = this.detectConflicts(drivers);
                
                // Calculate coherence
                const coherence = this.calculateCoherence(hits, conflicts);
                
                // Generate insights
                const insights = this.generateInsights(patterns, drivers, conflicts);
                
                return {
                    hits: hits,
                    patterns: patterns,
                    drivers: drivers,
                    conflicts: conflicts,
                    insights: insights,
                    coherence: coherence,
                    metadata: {
                        wordCount: words.length,
                        markerCount: hits.length,
                        markerDensity: hits.length / Math.max(1, words.length)
                    }
                };
            }
            
            createHit(word, position) {
                const marker = this.kb.lexicon[word];
                return {
                    word: word,
                    category: marker.category,
                    weight: marker.weight,
                    position: position,
                    patternName: this.kb.patterns[marker.category]?.name || marker.category
                };
            }
            
            aggregatePatterns(hits) {
                const patterns = {};
                
                hits.forEach(hit => {
                    const cat = hit.category;
                    if (!patterns[cat]) {
                        patterns[cat] = {
                            score: 0,
                            count: 0,
                            markers: [],
                            weight: 0
                        };
                    }
                    
                    patterns[cat].score += hit.weight;
                    patterns[cat].count++;
                    patterns[cat].weight += hit.weight;
                    patterns[cat].markers.push(hit.word);
                });
                
                // Calculate percentages
                const totalWeight = Object.values(patterns).reduce((sum, p) => sum + p.weight, 0);
                Object.keys(patterns).forEach(cat => {
                    patterns[cat].percentage = totalWeight > 0 ? (patterns[cat].weight / totalWeight) * 100 : 0;
                });
                
                return patterns;
            }
            
            inferDrivers(patterns) {
                const drivers = {};
                
                Object.entries(patterns).forEach(([cat, data]) => {
                    const pattern = this.kb.patterns[cat];
                    if (!pattern?.driver) return;
                    
                    const driver = pattern.driver;
                    if (!drivers[driver]) {
                        drivers[driver] = {
                            score: 0,
                            patterns: [],
                            totalWeight: 0
                        };
                    }
                    
                    drivers[driver].score += data.score;
                    drivers[driver].totalWeight += data.weight;
                    drivers[driver].patterns.push({
                        pattern: cat,
                        name: pattern.name,
                        weight: data.weight
                    });
                });
                
                // Normalize scores (0-10 scale)
                Object.keys(drivers).forEach(driver => {
                    drivers[driver].normalized = Math.min(10, drivers[driver].totalWeight / 3);
                });
                
                return drivers;
            }
            
            detectConflicts(drivers) {
                const conflicts = [];
                const driverKeys = Object.keys(drivers);
                
                // Check for conflicting drivers
                for (let i = 0; i < driverKeys.length; i++) {
                    for (let j = i + 1; j < driverKeys.length; j++) {
                        const d1 = driverKeys[i];
                        const d2 = driverKeys[j];
                        
                        // If both drivers are strong (score > 5), flag as conflict
                        if (drivers[d1].normalized > 5 && drivers[d2].normalized > 5) {
                            conflicts.push({
                                type: 'driver_conflict',
                                drivers: [d1, d2],
                                driverNames: [this.kb.drivers[d1]?.name, this.kb.drivers[d2]?.name],
                                severity: (drivers[d1].normalized + drivers[d2].normalized) / 20,
                                description: `Tension between ${this.kb.drivers[d1]?.name} and ${this.kb.drivers[d2]?.name}`
                            });
                        }
                    }
                }
                
                return conflicts;
            }
            
            calculateCoherence(hits, conflicts) {
                const base = 0.7;
                const conflictPenalty = conflicts.length * 0.1;
                const markerBonus = Math.min(0.2, hits.length / 50);
                
                return Math.max(0.1, Math.min(1, base - conflictPenalty + markerBonus));
            }
            
            generateInsights(patterns, drivers, conflicts) {
                const insights = [];
                
                // Top pattern insight
                const topPattern = Object.entries(patterns)
                    .sort((a, b) => b[1].weight - a[1].weight)[0];
                
                if (topPattern) {
                    insights.push({
                        type: 'pattern',
                        title: 'Primary Pattern',
                        content: `${this.kb.patterns[topPattern[0]]?.name}: ${this.kb.patterns[topPattern[0]]?.description}`
                    });
                }
                
                // Top driver insight
                const topDriver = Object.entries(drivers)
                    .sort((a, b) => b[1].normalized - a[1].normalized)[0];
                
                if (topDriver && topDriver[1].normalized > 4) {
                    insights.push({
                        type: 'driver',
                        title: 'Core Psychological Driver',
                        content: `${this.kb.drivers[topDriver[0]]?.name} (strength: ${topDriver[1].normalized.toFixed(1)}/10)`
                    });
                }
                
                // Conflict insight
                if (conflicts.length > 0) {
                    insights.push({
                        type: 'conflict',
                        title: 'Internal Tension',
                        content: conflicts[0].description
                    });
                }
                
                // Coherence insight
                const coherence = this.calculateCoherence([], conflicts);
                insights.push({
                    type: 'coherence',
                    title: 'Internal Consistency',
                    content: coherence > 0.6 ? 'Good internal coherence' : 
                            coherence > 0.4 ? 'Moderate coherence with some contradictions' :
                            'Significant internal contradictions'
                });
                
                return insights;
            }
        }

        // ========== GLOBAL VARIABLES ==========
        let engine = null;
        let currentAnalysis = null;

        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize engine
            engine = new CognitiveEngine(KNOWLEDGE_BASE);
            
            // Update word count in real-time
            const textInput = document.getElementById('textInput');
            textInput.addEventListener('input', updateStats);
            
            // Initial stats update
            updateStats();
            
            // Auto-analyze example text
            setTimeout(() => {
                analyzeText();
            }, 500);
        });

        // ========== BUTTON FUNCTIONS ==========
        function analyzeText() {
            const textInput = document.getElementById('textInput');
            const text = textInput.value.trim();
            
            if (!text) {
                alert('Please enter some text to analyze.');
                return;
            }
            
            if (text.length < 10) {
                alert('Please enter at least 10 characters for meaningful analysis.');
                return;
            }
            
            // Show loading state
            const analyzeBtn = document.getElementById('analyzeBtn');
            const originalText = analyzeBtn.innerHTML;
            analyzeBtn.innerHTML = '‚è≥ Analyzing...';
            analyzeBtn.disabled = true;
            
            // Perform analysis
            setTimeout(() => {
                try {
                    currentAnalysis = engine.analyze(text);
                    updateUI(currentAnalysis);
                    
                    // Show dashboard
                    document.getElementById('dashboard').style.display = 'grid';
                    
                    // Scroll to results
                    document.getElementById('dashboard').scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'start' 
                    });
                    
                } catch (error) {
                    console.error('Analysis error:', error);
                    alert('Analysis failed. Please try again.');
                } finally {
                    // Restore button
                    analyzeBtn.innerHTML = originalText;
                    analyzeBtn.disabled = false;
                }
            }, 300); // Small delay for better UX
        }
        
        function loadExample() {
            const examples = [
                "I always feel like I should be doing more, but nothing ever feels good enough. It's a disaster waiting to happen, and it's probably all my fault.",
                "Sometimes I worry that people think I'm not good enough. I should try harder, but when I do, I feel like a failure anyway.",
                "Everything has to be perfect or it's completely worthless. If I make one mistake, the whole thing is ruined.",
                "I'm never going to succeed at this rate. They probably think I'm incompetent. I should have done better.",
                "When things go wrong, it's always because of me. I'm the common denominator in every failure."
            ];
            
            const randomExample = examples[Math.floor(Math.random() * examples.length)];
            document.getElementById('textInput').value = randomExample;
            updateStats();
            
            // Auto-analyze the example
            setTimeout(analyzeText, 100);
        }
        
        function clearText() {
            document.getElementById('textInput').value = '';
            updateStats();
            document.getElementById('dashboard').style.display = 'none';
        }
        
        // ========== UI UPDATE FUNCTIONS ==========
        function updateStats() {
            const text = document.getElementById('textInput').value;
            const words = text.trim() === '' ? 0 : text.split(/\s+/).length;
            const chars = text.length;
            
            // Update counters
            document.getElementById('wordCount').textContent = words;
            document.getElementById('charCount').textContent = chars;
            
            // Estimate markers (rough count)
            const markerWords = Object.keys(KNOWLEDGE_BASE.lexicon);
            const markerCount = markerWords.reduce((count, word) => {
                const regex = new RegExp('\\b' + word + '\\b', 'gi');
                const matches = text.match(regex);
                return count + (matches ? matches.length : 0);
            }, 0);
            
            document.getElementById('markerCount').textContent = markerCount;
        }
        
        function updateUI(analysis) {
            updatePatterns(analysis.patterns);
            updateInsights(analysis.insights);
            updateConflicts(analysis.conflicts);
            updateMarkers(analysis.hits);
        }
        
        function updatePatterns(patterns) {
            const container = document.getElementById('patternsList');
            if (!container) return;
            
            const sortedPatterns = Object.entries(patterns)
                .sort((a, b) => b[1].weight - a[1].weight);
            
            if (sortedPatterns.length === 0) {
                container.innerHTML = '<div class="pattern-item">No patterns detected</div>';
                return;
            }
            
            container.innerHTML = sortedPatterns.map(([name, data]) => {
                const patternInfo = KNOWLEDGE_BASE.patterns[name];
                const percentage = Math.round(data.percentage);
                
                return `
                    <div class="pattern-item">
                        <div class="pattern-name">
                            ${patternInfo?.name || name}
                            <span style="float: right; color: var(--yellow); font-size: 0.9em;">
                                ${data.count} marker${data.count !== 1 ? 's' : ''}
                            </span>
                        </div>
                        <div class="pattern-score">
                            <div class="score-bar">
                                <div class="score-fill" style="width: ${percentage}%"></div>
                            </div>
                            <span style="font-size: 0.9em; color: var(--muted);">
                                ${percentage}%
                            </span>
                        </div>
                        <div style="font-size: 0.85em; color: var(--muted); margin-top: 5px;">
                            ${data.markers.slice(0, 3).map(m => 
                                `<span style="background: var(--purple); padding: 2px 6px; border-radius: 3px; margin-right: 5px;">${m}</span>`
                            ).join('')}
                            ${data.markers.length > 3 ? '...' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateInsights(insights) {
            const container = document.getElementById('insightsList');
            if (!container) return;
            
            if (!insights || insights.length === 0) {
                container.innerHTML = '<div class="insight-item">No insights generated</div>';
                return;
            }
            
            container.innerHTML = insights.map(insight => `
                <div class="insight-item">
                    <div style="font-weight: bold; color: var(--blue); margin-bottom: 5px;">
                        ${insight.title}
                    </div>
                    <div>${insight.content}</div>
                </div>
            `).join('');
        }
        
        function updateConflicts(conflicts) {
            const container = document.getElementById('conflictsList');
            if (!container) return;
            
            if (!conflicts || conflicts.length === 0) {
                container.innerHTML = '<div class="conflict-item">No conflicts detected. Good internal consistency!</div>';
                return;
            }
            
            container.innerHTML = conflicts.map(conflict => `
                <div class="conflict-item">
                    <div style="font-weight: bold; color: var(--red); margin-bottom: 5px;">
                        ${conflict.type.replace('_', ' ').toUpperCase()}
                    </div>
                    <div>${conflict.description}</div>
                    <div style="margin-top: 5px; font-size: 0.9em; color: var(--muted);">
                        Severity: ${(conflict.severity * 100).toFixed(0)}%
                    </div>
                </div>
            `).join('');
        }
        
        function updateMarkers(hits) {
            const container = document.getElementById('markersList');
            if (!container) return;
            
            if (!hits || hits.length === 0) {
                container.innerHTML = '<div>No cognitive markers found</div>';
                return;
            }
            
            // Group by category
            const byCategory = {};
            hits.forEach(hit => {
                if (!byCategory[hit.category]) {
                    byCategory[hit.category] = [];
                }
                byCategory[hit.category].push(hit.word);
            });
            
            container.innerHTML = Object.entries(byCategory)
                .map(([category, words]) => {
                    const uniqueWords = [...new Set(words)];
                    return `
                        <div style="margin-bottom: 10px;">
                            <div style="font-size: 0.9em; color: var(--muted); margin-bottom: 5px;">
                                ${KNOWLEDGE_BASE.patterns[category]?.name || category}
                            </div>
                            <div>
                                ${uniqueWords.map(word => 
                                    `<span class="marker ${category}">${word}</span>`
                                ).join(' ')}
                            </div>
                        </div>
                    `;
                }).join('');
            
            // Also highlight text in textarea
            highlightTextInTextarea(hits);
        }
        
        function highlightTextInTextarea(hits) {
            const textarea = document.getElementById('textInput');
            const text = textarea.value;
            
            // Create color mapping
            const colorMap = {
                'absolutist': '#FF2E63',
                'imperative': '#FFD700',
                'catastrophizing': '#FF6B35',
                'self_critic': '#AA00FF',
                'personalization': '#08D9D6',
                'mind_reading': '#00FF8C',
                'emotional': '#FF00F7'
            };
            
            let highlighted = text;
            
            // Sort hits by word length (longest first) to avoid overlapping replacements
            const sortedHits = [...hits].sort((a, b) => b.word.length - a.word.length);
            
            sortedHits.forEach(hit => {
                const color = colorMap[hit.category] || '#666666';
                const regex = new RegExp(`\\b${hit.word}\\b`, 'gi');
                highlighted = highlighted.replace(regex, 
                    `<mark style="background-color: ${color}80; color: white; padding: 2px 4px; border-radius: 3px; font-weight: bold;">$&</mark>`
                );
            });
            
            // Create a temporary div to show highlighted text
            const highlightDiv = document.createElement('div');
            highlightDiv.className = 'card';
            highlightDiv.style.marginTop = '20px';
            highlightDiv.innerHTML = `
                <h3>üî§ Highlighted Text</h3>
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; font-family: monospace; white-space: pre-wrap;">
                    ${highlighted}
                </div>
            `;
            
            // Remove existing highlight if any
            const existingHighlight = document.querySelector('.highlighted-text');
            if (existingHighlight) {
                existingHighlight.remove();
            }
            
            highlightDiv.className = 'card highlighted-text';
            document.getElementById('dashboard').appendChild(highlightDiv);
        }
        
        // ========== KEYBOARD SHORTCUTS ==========
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + Enter to analyze
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                analyzeText();
            }
            
            // Ctrl/Cmd + E for example
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                e.preventDefault();
                loadExample();
            }
            
            // Ctrl/Cmd + L to clear
            if ((e.ctrlKey || e.metaKey) && e.key === 'l') {
                e.preventDefault();
                clearText();
            }
        });
    </script>
</body>
</html>